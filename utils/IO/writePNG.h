// This file is part of libigl, a simple c++ geometry processing library.
//
// Copyright (C) 2016 Daniele Panozzo <daniele.panozzo@gmail.com>
//
// This Source Code Form is subject to the terms of the Mozilla Public License
// v. 2.0. If a copy of the MPL was not distributed with this file, You can
// obtain one at http://mozilla.org/MPL/2.0/.

#ifndef WRITE_PNG_H
#define WRITE_PNG_H

// Explicit template instantiation
// generated by autoexplicit.sh

#include "stb_image_write.h"
#include <vector>
#include <Eigen/Dense>

inline bool writePNG(
    const Eigen::Matrix<unsigned char,Eigen::Dynamic,Eigen::Dynamic>& R,
    const Eigen::Matrix<unsigned char,Eigen::Dynamic,Eigen::Dynamic>& G,
    const Eigen::Matrix<unsigned char,Eigen::Dynamic,Eigen::Dynamic>& B,
    const Eigen::Matrix<unsigned char,Eigen::Dynamic,Eigen::Dynamic>& A,
    const std::string png_file
)
{
    assert((R.rows() == G.rows()) && (G.rows() == B.rows()) && (B.rows() == A.rows()));
    assert((R.cols() == G.cols()) && (G.cols() == B.cols()) && (B.cols() == A.cols()));

    const int comp = 3;                                  // 4 Channels Red, Green, Blue, Alpha
    const int stride_in_bytes = R.cols()*comp;           // Length of one row in bytes
    std::vector<unsigned char> data(R.size()*comp,0);     // The image itself;

    for (unsigned i = 0; i<R.cols();++i)
    {
        for (unsigned j = 0; j < R.rows(); ++j)
        {
            data[(j * R.cols() * comp) + (i * comp) + 0] = R(R.rows()-1-j, i);
            data[(j * R.cols() * comp) + (i * comp) + 1] = G(R.rows()-1-j, i);
            data[(j * R.cols() * comp) + (i * comp) + 2] = B(R.rows()-1-j, i);
            //data[(j * R.rows() * comp) + (i * comp) + 3] = A(i,R.cols()-1-j);
        }
    }

    stbi_write_png(png_file.c_str(), R.cols(), R.rows(), comp, data.data(), stride_in_bytes);

    return true;
}

inline bool writePNG(
    const Eigen::MatrixXd& R,
    const Eigen::MatrixXd& G,
    const Eigen::MatrixXd& B,
    const Eigen::MatrixXd& A,
    const std::string png_file
)
{
    Eigen::Matrix<unsigned char,Eigen::Dynamic,Eigen::Dynamic> R_char;
    Eigen::Matrix<unsigned char,Eigen::Dynamic,Eigen::Dynamic> G_char;
    Eigen::Matrix<unsigned char,Eigen::Dynamic,Eigen::Dynamic> B_char;
    Eigen::Matrix<unsigned char,Eigen::Dynamic,Eigen::Dynamic> A_char;

    R_char = (R*255.9).cast<unsigned char> ();
    G_char = (G*255.9).cast<unsigned char> ();
    B_char = (B*255.9).cast<unsigned char> ();
    A_char = (A*255.9).cast<unsigned char> ();

    return writePNG(R_char, G_char, B_char, A_char, png_file);
};

// overload the functions
inline bool writePNG(
    const Eigen::MatrixXd& R,
    const Eigen::MatrixXd& G,
    const Eigen::MatrixXd& B,
    const std::string png_file
)
{
    Eigen::MatrixXd A = Eigen::MatrixXd::Ones(R.rows(), R.cols());

    return writePNG(R, G, B, A, png_file);
};

inline bool writePNG(
    const Eigen::MatrixXd& gray_map,
    const std::string png_file
)
{
    Eigen::MatrixXd R = gray_map;
    Eigen::MatrixXd G = gray_map;
    Eigen::MatrixXd B = gray_map;
    Eigen::MatrixXd A = Eigen::MatrixXd::Zero(gray_map.rows(), gray_map.cols());

    return writePNG(R, G, B, A, png_file);
};

inline bool writePNG(
    const Eigen::Matrix<bool,Eigen::Dynamic,Eigen::Dynamic>& binary_map,
    const std::string png_file
)
{
    Eigen::MatrixXd R = binary_map.cast<double> ();
    Eigen::MatrixXd G = binary_map.cast<double> ();
    Eigen::MatrixXd B = binary_map.cast<double> ();
    Eigen::MatrixXd A = Eigen::MatrixXd::Ones(binary_map.rows(), binary_map.cols());

    return writePNG(R, G, B, A, png_file);
};

#endif
